# Boost.Phoenix
[Boost.Phoenix](http://www.boost.org/libs/phoenix) - это самая важная Boost библиотека функционального программирования. Если библиотеки вроде Boost.Bind и Boost.Lambda
предоставляют некоторые дополнительные возможности для функционального программирования, то Boost.Phoenix не только включает в себя эти возможности, но и выходит за их рамки.

В функциональном программировании функции являются объектами и могут быть использованы в качетстве объектов. Используя Boost.Phoenix,можно написать функцию, которая может вернуть другую как рузультат.
Также Вы можете отправить функцию параметром в другую функцию. Стало возможным различать создание объекта функции и ее прямой вызов. Представление функции как объекта не эквивалентно ее исполнению.

Boost.Phoenix поддерживает функциональное программирование с использванием объектов функций: функции - это объекты классов, у которых перегружнен оператор operator().
Тогда функциональные объекты ведут себя как другие объекты в C++.
Например, они могут быть скопированы и сохранены в контейнере. Однако они также ведут себя как функции, потому что их можно вызвать.

Функциональное программирование не внове в C++. Вы можете передать функцию в качестве параметра в другую функцию, не используя Boost.Phoenix.

`Пример 39.1. Предикаты как глобальная функция, лямбда функция и функция Phoenix.`
<a name="example391"></a>
``` c++
#include <boost/phoenix/phoenix.hpp>
#include <vector>
#include <algorithm>
#include <iostream>

bool is_odd(int i) { return i % 2 == 1; }

int main()
{
  std::vector<int> v{1, 2, 3, 4, 5};

  std::cout << std::count_if(v.begin(), v.end(), is_odd) << '\n';

  auto lambda = [](int i){ return i % 2 == 1; };
  std::cout << std::count_if(v.begin(), v.end(), lambda) << '\n';

  using namespace boost::phoenix::placeholders;
  auto phoenix = arg1 % 2 == 1;
  std::cout << std::count_if(v.begin(), v.end(), phoenix) << '\n';
}
```
[Пример 39.1](#example391) показывает использование алгоритма  `std::count_if ()` для счета нечетных чисел в векторе v. `std::count_if()` вызывают три раза, один раз со стандратным предикатом, один раз с лямбда функцией, и один раз с Phoenix функцией.

Phoenix функция отличается от обычной функции и лямбда функции тем, что у нее нет всем привычной структуры. В то время как у других двух функций есть функциональный заголовок с подписью,Phoenix функция состоит только из тела функции.

Решающий компонент Phoenix функции-  ***boost::phoenix::placeholders::arg1***. **arg1** - глобальный экземпляр функционального объекта. Вы можете использовать его как **std::cout** : Эти объекты создаются, как только соответствующий заголовочный файл включен.


